# -*- coding: utf-8 -*-
"""Untitled3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16BU2RXc_rMAfse8LdIr-b8VWMTopnEA_
"""

# ============================================================================
# CELL 1: Setup and Installation
# ============================================================================
print("üì¶ Installing dependencies...")
!apt-get -qq install ffmpeg
!pip install -q moviepy pillow google-generativeai gtts google-genai
!pip install -q google-auth google-auth-oauthlib google-auth-httplib2 google-api-python-client

import os
import json
import asyncio
import pickle
from datetime import datetime
from moviepy.editor import *
from PIL import Image, ImageDraw, ImageFont
from gtts import gTTS

# YouTube API imports
from google_auth_oauthlib.flow import InstalledAppFlow
from googleapiclient.discovery import build
from googleapiclient.http import MediaFileUpload
from google.auth.transport.requests import Request

# Set up API key
GOOGLE_API_KEY = "AIzaSyBRuJ6qZF_7UZaOu4zCp8aFk0qlJvVQ2XY"  # Replace with your Gemini API key
os.environ["GOOGLE_API_KEY"] = GOOGLE_API_KEY

# Import ADK components
from google.adk.agents import Agent, SequentialAgent, ParallelAgent
from google.adk.models.google_llm import Gemini
from google.adk.runners import InMemoryRunner
from google.adk.tools import FunctionTool
from google.genai import types

# Create folder structure
!mkdir -p output/videos output/audio output/slides output/thumbnails logs

print("‚úÖ All dependencies installed!")
print("‚úÖ Folders created!")

# ============================================================================
# CELL 2: Retry Configuration
# ============================================================================
retry_config = types.HttpRetryOptions(
    attempts=5,
    exp_base=7,
    initial_delay=1,
    http_status_codes=[429, 500, 503, 504],
)

print("‚úÖ Retry config set")

# ============================================================================
# CELL 3: Tool Functions - Media Creation
# ============================================================================
def create_audio_from_script(script_text: str, topic: str) -> dict:
    """Generate TTS audio from script text

    Args:
        script_text: The narration script text to convert to speech
        topic: The video topic name for file naming

    Returns:
        dict: Contains audio_path, duration, and status
    """
    try:
        print(f"      üé§ Creating audio...")
        safe_topic = topic.replace(' ', '_').replace('/', '_')[:50]
        audio_path = f"output/audio/audio_{safe_topic}.mp3"

        tts = gTTS(text=script_text, lang='en', slow=False)
        tts.save(audio_path)

        # Get duration
        audio = AudioFileClip(audio_path)
        duration = audio.duration
        audio.close()

        print(f"      ‚úÖ Audio created: {duration:.1f}s")
        return {
            "audio_path": audio_path,
            "duration": duration,
            "status": "success"
        }
    except Exception as e:
        print(f"      ‚ùå Audio failed: {e}")
        return {"status": "error", "message": str(e)}

def create_slide_image(text: str, slide_num: int, total_slides: int, topic: str) -> str:
    """Create a single slide image"""
    img = Image.new('RGB', (1920, 1080), color='#ffffff')
    draw = ImageDraw.Draw(img)

    try:
        title_font = ImageFont.truetype("/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf", 80)
        body_font = ImageFont.truetype("/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf", 55)
        small_font = ImageFont.truetype("/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf", 28)
    except:
        title_font = body_font = small_font = ImageFont.load_default()

    # Top accent bar
    draw.rectangle([0, 0, 1920, 15], fill='#2563eb')

    # Bottom bar
    draw.rectangle([0, 1000, 1920, 1080], fill='#f1f5f9')

    # Slide number
    footer_text = f"Slide {slide_num} of {total_slides}"
    draw.text((60, 1025), footer_text, fill='#64748b', font=small_font)

    # Word wrap
    margin_left = 120
    max_width = 1920 - 240
    words = text.split()
    lines = []
    current_line = []

    for word in words:
        current_line.append(word)
        test_line = ' '.join(current_line)
        bbox = draw.textbbox((0, 0), test_line, font=body_font)
        if bbox[2] - bbox[0] > max_width:
            if len(current_line) > 1:
                lines.append(' '.join(current_line[:-1]))
                current_line = [word]

    if current_line:
        lines.append(' '.join(current_line))

    # Title slide vs content slide
    if slide_num == 1:
        y_offset = (1080 - len(lines) * 100) // 2
        for line in lines[:3]:
            bbox = draw.textbbox((0, 0), line, font=title_font)
            text_width = bbox[2] - bbox[0]
            x = (1920 - text_width) // 2
            draw.text((x, y_offset), line, fill='#1e293b', font=title_font)
            y_offset += 110

        line_y = y_offset + 20
        draw.rectangle([480, line_y, 1440, line_y + 4], fill='#2563eb')
    else:
        y_offset = 220
        for i, line in enumerate(lines[:5]):
            bullet_x = margin_left
            bullet_y = y_offset + 15
            draw.ellipse([bullet_x, bullet_y, bullet_x + 15, bullet_y + 15], fill='#2563eb')

            text_x = margin_left + 40
            draw.text((text_x, y_offset), line, fill='#1e293b', font=body_font)
            y_offset += 90

    # Save slide
    safe_topic = topic.replace(' ', '_').replace('/', '_')[:50]
    slide_path = f"output/slides/slide_{safe_topic}_{slide_num:03d}.png"
    img.save(slide_path)

    return slide_path

def create_slides_from_content(script_data: dict, topic: str) -> dict:
    """Create all slides from script data"""
    try:
        print(f"      üìä Creating slides...")
        slide_paths = []

        # Title slide
        title = script_data.get('title', topic)
        key_points = script_data.get('key_points', [])
        total_slides = len(key_points) + 1

        # Create title slide
        title_path = create_slide_image(title, 1, total_slides, topic)
        slide_paths.append(title_path)

        # Create content slides
        for i, point in enumerate(key_points, start=2):
            slide_path = create_slide_image(point, i, total_slides, topic)
            slide_paths.append(slide_path)

        print(f"      ‚úÖ Created {len(slide_paths)} slides")
        return {
            "slide_paths": slide_paths,
            "count": len(slide_paths),
            "status": "success"
        }
    except Exception as e:
        print(f"      ‚ùå Slides failed: {e}")
        return {"status": "error", "message": str(e)}

def create_thumbnail_image(title: str, topic: str) -> dict:
    """Create YouTube thumbnail"""
    try:
        print(f"      üé® Creating thumbnail...")
        img = Image.new('RGB', (1280, 720), color='#0f172a')
        draw = ImageDraw.Draw(img)

        try:
            title_font = ImageFont.truetype("/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf", 80)
        except:
            title_font = ImageFont.load_default()

        # Accent bars
        draw.rectangle([0, 0, 40, 720], fill='#3b82f6')
        draw.rectangle([1240, 0, 1280, 720], fill='#8b5cf6')

        # Word wrap
        words = title.split()
        lines = []
        current_line = []

        for word in words:
            current_line.append(word)
            test_line = ' '.join(current_line)
            bbox = draw.textbbox((0, 0), test_line, font=title_font)
            if bbox[2] - bbox[0] > 1100:
                if len(current_line) > 1:
                    lines.append(' '.join(current_line[:-1]))
                    current_line = [word]

        if current_line:
            lines.append(' '.join(current_line))

        # Draw title
        y_offset = (720 - len(lines) * 90) // 2
        for line in lines[:3]:
            bbox = draw.textbbox((0, 0), line, font=title_font)
            text_width = bbox[2] - bbox[0]
            x = (1280 - text_width) // 2
            draw.text((x, y_offset), line, fill='white', font=title_font)
            y_offset += 100

        safe_topic = topic.replace(' ', '_').replace('/', '_')[:50]
        thumbnail_path = f"output/thumbnails/thumb_{safe_topic}.png"
        img.save(thumbnail_path)

        print(f"      ‚úÖ Thumbnail created")
        return {
            "thumbnail_path": thumbnail_path,
            "status": "success"
        }
    except Exception as e:
        print(f"      ‚ùå Thumbnail failed: {e}")
        return {"status": "error", "message": str(e)}

def render_final_video(slide_paths_json: str, audio_path: str, topic: str) -> dict:
    """Render final video from slides and audio"""
    try:
        print(f"      üé¨ Rendering video...")
        from moviepy.editor import ImageClip, AudioFileClip, concatenate_videoclips

        # Parse slide_paths from JSON string
        slide_paths = json.loads(slide_paths_json)

        audio = AudioFileClip(audio_path)
        total_duration = audio.duration

        duration_per_slide = total_duration / len(slide_paths)

        clips = []
        for img_path in slide_paths:
            clip = ImageClip(img_path, duration=duration_per_slide)
            clips.append(clip)

        video = concatenate_videoclips(clips, method="compose")
        video = video.set_audio(audio)

        safe_topic = topic.replace(' ', '_').replace('/', '_')[:50]
        video_path = f"output/videos/video_{safe_topic}.mp4"

        video.write_videofile(
            video_path,
            fps=24,
            codec='libx264',
            audio_codec='aac',
            preset='medium',
            temp_audiofile='temp-audio.m4a',
            remove_temp=True,
            logger=None
        )

        video.close()
        audio.close()

        file_size = round(os.path.getsize(video_path) / (1024 * 1024), 2)
        print(f"      ‚úÖ Video rendered: {file_size}MB")

        return {
            "video_path": video_path,
            "file_size_mb": file_size,
            "status": "success"
        }
    except Exception as e:
        print(f"      ‚ùå Rendering failed: {e}")
        import traceback
        traceback.print_exc()
        return {"status": "error", "message": str(e)}

print("‚úÖ Media creation tool functions loaded")

# ============================================================================
# CELL 4: YouTube Upload Tool Function - COLAB FIXED
# ============================================================================

def upload_to_youtube(
    video_path: str,
    title: str,
    description: str,
    tags: str,
    privacy_status: str = "private"
) -> dict:
    """Upload video to YouTube - Colab Compatible Version

    Args:
        video_path: Path to the video file
        title: Video title
        description: Video description
        tags: Comma-separated tags as string
        privacy_status: "public", "private", or "unlisted"

    Returns:
        dict: Contains video_id, url, and status
    """
    SCOPES = ['https://www.googleapis.com/auth/youtube.upload']

    credentials = None

    # Check if we have saved credentials
    if os.path.exists('token.pickle'):
        print("   üìÇ Loading saved credentials...")
        with open('token.pickle', 'rb') as token:
            credentials = pickle.load(token)

    # If credentials don't exist or are invalid, get new ones
    if not credentials or not credentials.valid:
        if credentials and credentials.expired and credentials.refresh_token:
            print("   üîÑ Refreshing expired credentials...")
            credentials.refresh(Request())
        else:
            # Check for client_secrets.json
            if not os.path.exists('client_secrets.json'):
                return {
                    "status": "error",
                    "message": "‚ùå client_secrets.json not found! Please upload it first.",
                    "video_id": None,
                    "url": None,

                }

            print("   üîê Starting OAuth authentication...")
            print("   ‚ö†Ô∏è  COLAB AUTHENTICATION MODE")

            # Use flow without local server (Colab-compatible)
            flow = InstalledAppFlow.from_client_secrets_file(
                'client_secrets.json',
                SCOPES,
                redirect_uri='urn:ietf:wg:oauth:2.0:oob'  # Manual code entry
            )

            # Get authorization URL
            auth_url, _ = flow.authorization_url(prompt='consent')

            print("\n" + "="*70)
            print("üîó AUTHENTICATION REQUIRED")

# ============================================================================
# CELL 5: Script Generation Agent
# ============================================================================

script_agent = Agent(
    name="ScriptAgent",
    model=Gemini(
        model="gemini-2.5-flash-lite",
        retry_options=retry_config
    ),
    instruction="""You are a professional content writer for educational YouTube videos.

    Given a topic from the user, create a complete video script with the following structure:

    1. A catchy, SEO-friendly title (under 60 characters)
    2. A full narration script (approximately 150 words for a 60-second video)
    3. Exactly 5 key points that will be displayed as slides
    4. 5 relevant tags for YouTube
    5. A 2-3 sentence description for YouTube

    CRITICAL: Return ONLY a valid JSON object with NO markdown formatting, NO code blocks, NO backticks.
    Just pure JSON like this:

    {"title": "Your catchy title here", "script": "Full narration text that will be spoken...", "key_points": ["First key point", "Second key point", "Third key point", "Fourth key point", "Fifth key point"], "tags": ["tag1", "tag2", "tag3", "tag4", "tag5"], "description": "YouTube description text"}

    Make the content engaging, educational, and easy to understand.""",
    output_key="script_data"
)

print("‚úÖ ScriptAgent created")

# ============================================================================
# CELL 6: Audio Generation Agent
# ============================================================================

audio_agent = Agent(
    name="AudioAgent",
    model=Gemini(
        model="gemini-2.5-flash-lite",
        retry_options=retry_config
    ),
    instruction="""You are an audio production agent.

    You have access to script_data from the ScriptAgent which contains a 'script' field with the narration text.

    Extract the script text and call create_audio_from_script with:
    - script_text: the value from script_data['script']
    - topic: the original user query (the topic they asked about)

    Call the function now with these parameters.""",
    tools=[FunctionTool(create_audio_from_script)],
    output_key="audio_data"
)

print("‚úÖ AudioAgent created")

# ============================================================================
# CELL 7: Slides Generation Agent
# ============================================================================

slides_agent = Agent(
    name="SlidesAgent",
    model=Gemini(
        model="gemini-2.5-flash-lite",
        retry_options=retry_config
    ),
    instruction="""You are a visual design agent specializing in presentation slides.

    You have access to script_data from the ScriptAgent.

    Call create_slides_from_content with:
    - script_data: pass the entire script_data dictionary
    - topic: the original user query

    Call the function now.""",
    tools=[FunctionTool(create_slides_from_content)],
    output_key="slides_data"
)

print("‚úÖ SlidesAgent created")

# ============================================================================
# CELL 8: Thumbnail Generation Agent
# ============================================================================
thumbnail_agent = Agent(
    name="ThumbnailAgent",
    model=Gemini(
        model="gemini-2.5-flash-lite",
        retry_options=retry_config
    ),
    instruction="""You are a thumbnail designer agent.

    You have access to script_data from the ScriptAgent which contains a 'title' field.

    Call create_thumbnail_image with:
    - title: the value from script_data['title']
    - topic: the original user query

    Call the function now.""",
    tools=[FunctionTool(create_thumbnail_image)],
    output_key="thumbnail_data"
)

print("‚úÖ ThumbnailAgent created")

# ============================================================================
# CELL 9: Video Rendering Agent
# ============================================================================

render_agent = Agent(
    name="RenderAgent",
    model=Gemini(
        model="gemini-2.5-flash-lite",
        retry_options=retry_config
    ),
    instruction="""You are a video rendering agent.

    You have:
    - slides_data containing 'slide_paths' (a list of file paths)
    - audio_data containing 'audio_path' (a string path)

    Steps:
    1. Extract slide_paths list from slides_data
    2. Convert to JSON string: json.dumps(slide_paths)
    3. Extract audio_path from audio_data
    4. Call render_final_video(slide_paths_json, audio_path, topic)

    The slide_paths_json parameter must be a JSON string (use json.dumps).

    Call the function now.""",
    tools=[FunctionTool(render_final_video)],
    output_key="video_data"
)

print("‚úÖ RenderAgent created")

# ============================================================================
# CELL 10: YouTube Upload Agent
# ============================================================================

youtube_agent = Agent(
    name="YouTubeAgent",
    model=Gemini(
        model="gemini-2.5-flash-lite",
        retry_options=retry_config
    ),
    instruction="""You are a YouTube upload agent.

    You have:
    - video_data containing 'video_path'
    - script_data containing 'title', 'description', and 'tags' (list)

    Steps:
    1. Extract video_path from video_data
    2. Extract title from script_data
    3. Extract description from script_data
    4. Convert tags list to comma-separated string: ", ".join(script_data['tags'])
    5. Call upload_to_youtube(video_path, title, description, tags_string, "private")

    IMPORTANT: tags must be a comma-separated string like "ai, tech, education"

    Call the function now.""",
    tools=[FunctionTool(upload_to_youtube)],
    output_key="youtube_data"
)

print("‚úÖ YouTubeAgent created")

# ============================================================================
# CELL 11: Complete Multi-Agent Pipeline
# ============================================================================

# Parallel agents for audio, slides, and thumbnail (run simultaneously)
parallel_media_team = ParallelAgent(
    name="MediaProductionTeam",
    sub_agents=[audio_agent, slides_agent, thumbnail_agent]
)

# Sequential pipeline: Script ‚Üí Media (parallel) ‚Üí Render ‚Üí YouTube Upload
root_agent = SequentialAgent(
    name="YouTubeAutoUploader",
    sub_agents=[
        script_agent,           # 1. Generate script
        parallel_media_team,    # 2. Create audio, slides, thumbnail (parallel)
        render_agent,           # 3. Render video
        youtube_agent           # 4. Upload to YouTube
    ]
)

print("‚úÖ Complete multi-agent pipeline created!")
print("\nüìä Pipeline Structure:")
print("   1Ô∏è‚É£  ScriptAgent        - Generate video script")
print("   2Ô∏è‚É£  ParallelTeam:")
print("      ‚îú‚îÄ AudioAgent       - Create voiceover")
print("      ‚îú‚îÄ SlidesAgent      - Generate slides")
print("      ‚îî‚îÄ ThumbnailAgent   - Create thumbnail")
print("   3Ô∏è‚É£  RenderAgent        - Render final video")
print("   4Ô∏è‚É£  YouTubeAgent       - Upload to YouTube")

# ============================================================================
# CELL 12: Initialize Runner
# ============================================================================

runner = InMemoryRunner(agent=root_agent)

print("‚úÖ Runner initialized and ready!")

async def create_and_upload_video(topic):
    """Create a complete video and upload to YouTube"""
    print(f"\n{'='*70}")
    print(f"üé¨ YOUTUBE AUTO-UPLOADER - STARTING PIPELINE")
    print(f"{'='*70}")
    print(f"üìã Topic: {topic}")
    print(f"‚è∞ Started: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"{'='*70}\n")

    start_time = datetime.now()

    try:
        response = await runner.run_debug(topic)

        duration = (datetime.now() - start_time).total_seconds()

        print(f"\n{'='*70}")
        print(f"‚úÖ PIPELINE COMPLETE!")
        print(f"{'='*70}")
        print(f"‚è±Ô∏è  Total time: {duration:.1f} seconds")
        print(f"üì∫ Video created and uploaded to YouTube!")
        print(f"{'='*70}\n")

        return response
    except Exception as e:
        print(f"\n{'='*70}")
        print(f"‚ùå PIPELINE FAILED")
        print(f"{'='*70}")
        print(f"Error: {str(e)}")
        import traceback
        traceback.print_exc()
        print(f"{'='*70}\n")
        raise

# CREATE YOUR FIRST VIDEO!
response = await create_and_upload_video("How Machine Learning Works")

print("\nüìä Final Response:")

from google.colab import files
from IPython.display import Video, display

def show_results():
    """Display all created files and upload status"""
    print("\n" + "="*70)
    print("üìä CREATION SUMMARY")
    print("="*70)

    # Videos
    print("\nüìπ Created Videos:")
    video_files = [f for f in os.listdir('output/videos/') if f.endswith('.mp4')]
    for vf in video_files:
        size = os.path.getsize(f'output/videos/{vf}') / (1024*1024)
        print(f"   ‚Ä¢ {vf} ({size:.1f} MB)")

    # Thumbnails
    print("\nüé® Created Thumbnails:")
    thumb_files = [f for f in os.listdir('output/thumbnails/') if f.endswith('.png')]
    for tf in thumb_files:
        print(f"   ‚Ä¢ {tf}")

    # Audio
    print("\nüé§ Created Audio:")
    audio_files = [f for f in os.listdir('output/audio/') if f.endswith('.mp3')]
    for af in audio_files:
        duration_info = ""
        print(f"   ‚Ä¢ {af}")

    print("\n" + "="*70)
    print("üì∫ YOUTUBE UPLOAD STATUS")
    print("="*70)
    print("\nüí° To view your uploaded videos:")
    print("   1. Go to: https://studio.youtube.com")
    print("   2. Click 'Content' in left sidebar")
    print("   3. Your videos will be listed as 'Private'")
    print("\n‚öôÔ∏è  To make videos public:")
    print("   1. Click on the video in YouTube Studio")
    print("   2. Click 'Visibility'")
    print("   3. Change from 'Private' to 'Public' or 'Unlisted'")
    print("   4. Click 'Save'")
    print("="*70)

    # Play latest video
    if video_files:
        latest_video = f"output/videos/{video_files[-1]}"
        print(f"\nüé¨ Playing latest video: {video_files[-1]}\n")
        display(Video(latest_video, width=800))

show_results()

def download_all_files():
    """Download video, thumbnail, and audio"""
    from google.colab import files

    video_files = [f for f in os.listdir('output/videos/') if f.endswith('.mp4')]
    thumb_files = [f for f in os.listdir('output/thumbnails/') if f.endswith('.png')]

    if video_files:
        print("üì• Downloading video...")
        files.download(f'output/videos/{video_files[-1]}')

    if thumb_files:
        print("üì• Downloading thumbnail...")
        files.download(f'output/thumbnails/{thumb_files[-1]}')

    print("‚úÖ Downloads started!")


download_all_files()

async def batch_create_and_upload(topics, privacy="private"):
    """Create and upload multiple videos to YouTube

    Args:
        topics: List of video topics
        privacy: "private", "public", or "unlisted"
    """
    results = []
    total_start = datetime.now()

    print(f"\n{'='*70}")
    print(f"üé¨ BATCH PROCESSING: {len(topics)} videos")
    print(f"{'='*70}\n")

    for i, topic in enumerate(topics, 1):
        print(f"\n{'‚îÄ'*70}")
        print(f"üìπ Video {i}/{len(topics)}: {topic}")
        print(f"{'‚îÄ'*70}")

        try:
            response = await create_and_upload_video(topic)
            results.append({
                "topic": topic,
                "status": "success",
                "response": response
            })
            print(f"‚úÖ Video {i} completed and uploaded!")
        except Exception as e:
            print(f"‚ùå Video {i} failed: {e}")
            results.append({
                "topic": topic,
                "status": "failed",
                "error": str(e)
            })

    # Final summary
    total_duration = (datetime.now() - total_start).total_seconds()
    successful = len([r for r in results if r['status'] == 'success'])

    print(f"\n{'='*70}")
    print(f"üìä BATCH PROCESSING COMPLETE")
    print(f"{'='*70}")
    print(f"‚úÖ Successful: {successful}/{len(topics)}")
    print(f"‚ùå Failed:     {len(topics) - successful}/{len(topics)}")
    print(f"‚è±Ô∏è  Total time: {total_duration:.1f}s")
    print(f"‚ö° Avg per video: {total_duration/len(topics):.1f}s")
    print(f"{'='*70}\n")

    return results

# Define your batch topics
batch_topics = [
    "How Neural Networks Learn",
    "What is Blockchain Technology",
    "Quantum Computing Explained"
]


batch_results = await batch_create_and_upload(batch_topics, privacy="private")

print("‚úÖ Batch processing function ready")